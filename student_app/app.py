from flask import Flask, request, jsonify
from dotenv import load_dotenv
import os

load_dotenv()
app = Flask(__name__)

@app.route('/', methods=['POST'])
def handle_task():
    """
    Handles incoming task requests.
    """
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400

    data = request.get_json()
    print("Received task:", data)

    # Secret verification
    app_secret = os.environ.get('APP_SECRET')
    if not app_secret:
        return jsonify({"error": "Application secret not configured"}), 500

    request_secret = data.get('secret')
    if request_secret != app_secret:
        return jsonify({"error": "Invalid secret"}), 401

    # Application Generation
    brief = data.get('brief')
    if not brief:
        return jsonify({"error": "Brief not provided"}), 400

    attachments = data.get('attachments', [])
    app_files = generate_app_code(brief, attachments)
    print("Generated app files:", app_files.keys())

    # GitHub Deployment
    task_id = data.get('task')
    if not task_id:
        return jsonify({"error": "Task ID not provided"}), 400

    repo_details = deploy_to_github(task_id, brief, app_files)
    print("Deployment details:", repo_details)

    # Evaluation Notification
    evaluation_url = data.get('evaluation_url')
    if not evaluation_url:
        return jsonify({"error": "Evaluation URL not provided"}), 400

    notification_status = notify_evaluation_service(evaluation_url, data, repo_details)
    print("Notification status:", notification_status)

    return jsonify({"message": "Request received successfully"}), 200

import base64
import csv
from io import StringIO
import json
import re

def generate_app_code(brief: str, attachments: list) -> dict:
    """
    Generates application code based on the brief and attachments.
    """
    if "sum-of-sales" in brief:
        return generate_sum_of_sales_app(brief, attachments)
    elif "markdown-to-html" in brief:
        return generate_markdown_to_html_app(brief, attachments)
    else:
        # Fallback to LLM-based generation for other briefs
        return generate_app_with_llm(brief, attachments)

def generate_app_with_llm(brief: str, attachments: list) -> dict:
    """
    Generates application code using an LLM.
    Currently, a placeholder.
    """
    print("Generating app with LLM...")
    # In a real implementation, this would call an LLM API
    # to generate the code based on the brief and attachments.
    return {
        "index.html": f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Generated App</title>
</head>
<body>
    <h1>Application Brief</h1>
    <p>{brief}</p>
    <p><i>(This page was generated by a placeholder LLM.)</i></p>
</body>
</html>
"""
    }

def generate_sum_of_sales_app(brief: str, attachments: list) -> dict:
    """
    Generates the sum-of-sales application.
    """
    # Find the data.csv attachment
    csv_attachment = next((att for att in attachments if att['name'] == 'data.csv'), None)
    if not csv_attachment:
        raise ValueError("data.csv attachment not found")

    # Decode the CSV data
    csv_data_uri = csv_attachment['url']
    header, encoded = csv_data_uri.split(',', 1)
    decoded_csv = base64.b64decode(encoded).decode('utf-8')

    # Calculate the total sales
    total_sales = 0
    reader = csv.DictReader(StringIO(decoded_csv))
    for row in reader:
        total_sales += float(row.get('sales', 0))

    # Extract seed from brief
    match = re.search(r'Sales Summary \${(\S+)}', brief)
    seed = match.group(1) if match else "Default"
    title = f"Sales Summary {seed}"

    # Generate the HTML
    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container">
        <h1>Sales Summary</h1>
        <p>Total Sales: <span id="total-sales">{total_sales:.2f}</span></p>
    </div>
</body>
</html>
"""
    return {"index.html": html_content}

def generate_markdown_to_html_app(brief: str, attachments: list) -> dict:
    """
    Generates the markdown-to-html application.
    """
    # Find the input.md attachment
    md_attachment = next((att for att in attachments if att['name'] == 'input.md'), None)
    if not md_attachment:
        raise ValueError("input.md attachment not found")

    # Decode the Markdown data
    md_data_uri = md_attachment['url']
    header, encoded = md_data_uri.split(',', 1)
    decoded_md = base64.b64decode(encoded).decode('utf-8')

    # Generate the HTML
    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <div id="markdown-output"></div>
    <script>
        const markdownContent = ${json.dumps(decoded_md)};
        document.getElementById('markdown-output').innerHTML = marked.parse(markdownContent);
        hljs.highlightAll();
    </script>
</body>
</html>
"""
    return {"index.html": html_content}

import requests
from github import Github
import time

def deploy_to_github(task_id: str, brief: str, app_files: dict) -> dict:
    """
    Deploys the application code to GitHub.
    """
    github_token = os.environ.get('GITHUB_TOKEN')
    if not github_token:
        raise ValueError("GitHub token not configured")

    g = Github(github_token)
    user = g.get_user()

    # Create a new repository
    repo = user.create_repo(task_id, private=False)
    print(f"Created repository: {repo.full_name}")

    # Upload the application files
    for filename, content in app_files.items():
        repo.create_file(filename, f"Add {filename}", content)

    # Add a LICENSE file
    license_content = """
MIT License

Copyright (c) 2023

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
    repo.create_file("LICENSE", "Add LICENSE", license_content)

    # Add a README.md file
    readme_content = f"""
# {task_id}

This is a web application generated to fulfill the requirements of the task brief.

## Summary

{brief}

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
"""
    repo.create_file("README.md", "Add README.md", readme_content)

    # Enable GitHub Pages
    headers = {
        "Authorization": f"token {github_token}",
        "Accept": "application/vnd.github.v3+json"
    }
    pages_payload = {
        "source": {"branch": "main", "path": "/"}
    }
    pages_url_endpoint = f"https://api.github.com/repos/{user.login}/{task_id}/pages"
    response = requests.post(pages_url_endpoint, headers=headers, json=pages_payload)

    if response.status_code == 201:
        print("GitHub Pages creation request accepted.")
        # Wait for the site to be built
        for _ in range(30):  # Poll for up to 5 minutes
            try:
                pages_site_response = requests.get(pages_url_endpoint, headers=headers)
                pages_site_response.raise_for_status()
                pages_site = pages_site_response.json()
                if pages_site.get("status") == "built":
                    print("GitHub Pages site has been built successfully.")
                    break
            except requests.exceptions.RequestException as e:
                print(f"Waiting for GitHub Pages to build... ({e})")
            time.sleep(10)
        else:
            print("GitHub Pages site did not build in time.")
    else:
        print(f"Failed to create GitHub Pages site: {response.status_code} {response.text}")

    pages_url = f"https://{user.login}.github.io/{task_id}/"
    print(f"Enabled GitHub Pages at: {pages_url}")

    # Get the latest commit SHA
    commit_sha = repo.get_branch("main").commit.sha

    return {
        "repo_url": repo.html_url,
        "commit_sha": commit_sha,
        "pages_url": pages_url
    }

def notify_evaluation_service(evaluation_url: str, request_data: dict, repo_details: dict) -> str:
    """
    Notifies the evaluation service about the deployment.
    """
    payload = {
        "email": request_data.get('email'),
        "task": request_data.get('task'),
        "round": request_data.get('round'),
        "nonce": request_data.get('nonce'),
        "repo_url": repo_details.get('repo_url'),
        "commit_sha": repo_details.get('commit_sha'),
        "pages_url": repo_details.get('pages_url'),
    }

    max_retries = 5
    retry_delay = 1  # start with 1 second

    for attempt in range(max_retries):
        try:
            response = requests.post(evaluation_url, json=payload)
            response.raise_for_status()  # Raise an exception for bad status codes
            return f"Notification sent successfully: {response.status_code}"
        except requests.exceptions.RequestException as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if attempt < max_retries - 1:
                print(f"Retrying in {retry_delay} seconds...")
                time.sleep(retry_delay)
                retry_delay *= 2  # Exponential backoff
            else:
                return "Failed to send notification after multiple retries."
